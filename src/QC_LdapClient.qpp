/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  QC_LdapClient.qpp
  
  Qore Programming Language
  
  Copyright 2003 - 2012 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.
  
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "openldap-module.h"

#include "QoreLdapClient.h"

class LdapClientHolder {
protected:
   QoreLdapClient* ldap;
   ExceptionSink* xsink;

public:
   DLLLOCAL LdapClientHolder(QoreLdapClient* l, ExceptionSink* xs) : ldap(l), xsink(xs) {
   }

   DLLLOCAL ~LdapClientHolder() {
      if (ldap) {
         ldap->destructor(xsink);
         ldap->deref(xsink);
      }
   }

   DLLLOCAL QoreLdapClient* release() {
      QoreLdapClient* l = ldap;
      ldap = 0;
      return l;
   }
};

/** @defgroup ldap_scope_constants LDAP Search Scope Constants
 */
//@{
namespace OpenLdap;

//! limits the search scope to the object itself
const LDAP_SCOPE_BASE = LDAP_SCOPE_BASE;

//! limits the search scope to the object's immediate children
const LDAP_SCOPE_ONELEVEL = LDAP_SCOPE_ONELEVEL;

//! limits the search scope to the object and all its descendants
const LDAP_SCOPE_SUBTREE = LDAP_SCOPE_SUBTREE;

//! limits the search scope to all of the descendants
/** this option is only supported on LDAP servers that support the LDAP Subordinates Search Scope extension
 */
const LDAP_SCOPE_CHILDREN = LDAP_SCOPE_CHILDREN;
//@}

/** @defgroup ldap_modify_constants LDAP Modify Constants
 */
//@{
namespace OpenLdap;
//! for adding an entry
const LDAP_MOD_ADD = "add";

//! for deleting an entry
const LDAP_MOD_DELETE = "delete";

//! for replacing an entry
const LDAP_MOD_REPLACE = "replace";
//@}

/** @defgroup ldap_constants LDAP Constants
 */
//@{
namespace OpenLdap;

//! the default timeout value
const DefaultTimeout = 60s;
//@}

//! The LdapClient class 
/** 
 */
qclass LdapClient [arg=QoreLdapClient* ldap; dom=NETWORK];

//! Creates a new LdapClient object
/** 
    @par Example:
    @code
my LdapClient $ldap("ldaps://ldap.example.com:389", ("starttls": True, "timeout": 20s));
    @endcode

    @param uri the URI of the ldap server (ex: \c "ldaps://ldap.example.com")
    @param options an optional hash of optional parameters, allowed keys are:
    - \c binddn: the dinstinguished name to use to bind to the LDAP server
    - \c password: the password to use for the connection
    - \c timeout: the default timeout for ldap operations; note that like all %Qore functions and methods taking timeout values, a relative date/time value can be used to make the units clear (i.e. \c 20s = twenty seconds, etc.); integers are treated as values in milliseconds, relative date/time values have a maximum resolution of 1 millisecond
    - \c no-referrals: (boolean) do not follow referrals (the default is to follow referrals)
    - \c starttls: (boolean) if set, then a \c STARTTLS command will be executed if a secure connection is not already established; note that setting this option will ensure a secure connection regardless of the scheme in the URI

    @throw LDAP-ERROR an error occurred creating the ldap session context
 */
LdapClient::constructor(string uri, *hash options) {
   LdapClientHolder ldap(new QoreLdapClient(uri, options, xsink), xsink);
   if (!*xsink)
      self->setPrivate(CID_LDAPCLIENT, ldap.release());
}

//! unbinds from the LDAP server (if a connection has been established) and destroys the object
/** @par Example:
    @code
delete $ldap;
    @endcode
 */
LdapClient::destructor() {
   ldap->destructor(xsink);
   ldap->deref(xsink);
}

//! Creates a new LdapClient object based on the original
/** 
    @par Example:
    @code
my LdapClient $ldap2 = $ldap.copy();
    @endcode

    @throw LDAP-ERROR an error occurred copying the ldap session context
 */
LdapClient::copy() {
   LdapClientHolder ldp(new QoreLdapClient(*ldap, xsink), xsink);
   if (!*xsink)
      self->setPrivate(CID_LDAPCLIENT, ldp.release());
}

//! bind to the server with the given authentication parameters
/** The current session is disconnected before binding again.

    @par Example:
    @code
$ldap.bind($h);
    @endcode

    @param bind a hash of bind parameters, allowed keys are:
    - \c binddn: the dinstinguished name to use to bind to the LDAP server
    - \c password: the password to use for the connection

    @throw LDAP-NO-CONTEXT the LDAP session is not connected or the session context is not bound
    @throw LDAP-BIND-ERROR parameter type error or 'password' given with no 'binddn' value
    @throw LDAP-ERROR an error occurred performing the bind
 */
LdapClient::bind(hash bind) {
   ldap->bind(*bind, xsink);
}

//! performs a search on the LDAP server 
/** @par Example:
    @code
my hash $h = $ldap.search(("base": "dc=example,dc=cp,", "filter": "(objectClass=*)", "attributes": "uid");
    @endcode

    @param h a hash of search options with one or more of the following keys:
    - \c "base": the search base distinguished name for the search (ex: \c "dc=example,dc=com")
    - \c "filter": the search filter (ex: \c "(objectClass=*)")
    - \c "attributes": one or more attribute names; if this is present then only the given attributes will be returned
    - \c "scope": an integer giving the search scope; see @ref ldap_scope_constants for allowed values; note that if this key value is not present then @ref LDAP_SCOPE_SUBTREE is used

    @return a hash of the return value of the search; the hash is empty if no search results are available; the hash is keyed by Distinguished Names; each value is also a hash of attributes and attribute values

    @throw LDAP-NO-CONTEXT the LDAP session is not connected or the session context is not bound
    @throw LDAP-ERROR an error occurred performing the search
 */
hash LdapClient::search(hash h) {
   const QoreStringNode* base = check_hash_key<QoreStringNode>(xsink, *h, "base", "LDAP-SEARCH-ERROR");
   const QoreStringNode* filter = check_hash_key<QoreStringNode>(xsink, *h, "filter", "LDAP-SEARCH-ERROR");
   const AbstractQoreNode* n = h->getKeyValue("attributes");
   ReferenceHolder<QoreListNode> attrl(xsink);
   if (n) {
      if (n->getType() == NT_STRING) {
         attrl = new QoreListNode;
         attrl->push(n->refSelf());
      }
      else if (n->getType() == NT_LIST)
         attrl = reinterpret_cast<const QoreListNode*>(n)->listRefSelf();
      else {
         xsink->raiseException("LDAPCLIENT-SEARCH-ERROR", "the 'attributes' key of the search hash contains type '%s' (expecting 'list' or 'string')", get_type_name(n));
         return 0;
      }
   }

   // get scope
   n = h->getKeyValue("scope");
   int scope = n ? n->getAsInt() : 0;
   if (!scope)
      scope = LDAP_SCOPE_SUBTREE;
   
   return ldap->search(xsink, base, scope, filter, *attrl);
}

//! add ldap an entry and attributes
/** Give the new entry's objectclass as an attribute; an attribute value can be a list to add multiple values to an attribute

    @par Example:
    @code
$ldap.add("uid=temp,ou=people,dc=example,dc=com", ("objectclass": "inetorgperson", "sn": "Test", "cn": "test test"));
    @endcode

    @param dn the distinguished name of the entry to add
    @param attrs a hash of new attributes; the keys are attribute names and the values are the attribute values
    
    @throw LDAP-NO-CONTEXT the LDAP session is not connected or the session context is not bound
    @throw LDAP-ADD-ERROR missing attribute value
    @throw LDAP-ERROR an error occurred performing the add operation
*/
nothing LdapClient::add(string dn, hash attrs) {
   ldap->add(xsink, dn, attrs);
}

//! modify (add, replace, delete) ldap attributes; if any errors occur (entry does not exist, etc), an \c LDAP-ERROR exception will be thrown
/** @par Example:
    @code
$ldap.modify("uid=temp,ou=people,dc=example,dc=com", ("mod": LDAP_MOD_ADD, "attr": "someattr", "value": "new-value"));
    @endcode

    @param dn the distinguished name of the entry to modify
    @param mods a hash or list of hashes of modifications to make; each hash is made up of the following keys:
    - \c mod: a modification action; see @ref ldap_modify_constants for possible values
    - \c attr: the attribute to modify
    - [\c value]: the value to add or replace 
    
    @throw LDAP-NO-CONTEXT the LDAP session is not connected or the session context is not bound
    @throw LDAP-MODIFY-ERROR invalid mod hash format; missing value for add or replace operation
    @throw LDAP-ERROR an error occurred performing the modify operation
*/
nothing LdapClient::modify(string dn, softlist mods) {
   ldap->modify(xsink, dn, mods);
}

//! delete ldap entries; if any errors occur (entry does not exist, etc), an \c LDAP-ERROR exception will be thrown
/** @par Example:
    @code
$ldap.del("uid=temp,ou=people,dc=example,dc=com");
    @endcode

    @param dn the distinguished name of the entry to delete

    @throw LDAP-NO-CONTEXT the LDAP session is not connected or the session context is not bound
    @throw LDAP-ERROR an error occurred performing the delete operation
 */
nothing LdapClient::del(string dn) {
   ldap->del(xsink, dn);
}

//! returns the URI string used to connect to the LDAP server
/** @par Example:
    @code
my string $uri = $ldap.getUri();
    @endcode

    @return the URI string used to connect to the LDAP server
*/
string LdapClient::getUri() [flags=CONSTANT] {
   return ldap->getUriStr();
}

//! returns \c True if the connection to the server is secure, \c False if not
/** @par Example:
    @code
my bool $b = $ldap.isSecure();
    @endcode

    @return \c True if the connection to the server is secure, \c False if not

    @throw LDAP-NO-CONTEXT the LDAP session is not connected or the session context is not bound
 */
bool LdapClient::isSecure() [flags=RET_VALUE_ONLY] {
   return ldap->isSecure(xsink);
}

//! Returns a hash with information about the openldap library
/** @return a hash with information about the openldap library with the following keys:
    - \c ApiVersion: the API version number
    - \c Protocol: the protocol number
    - \c VendorName: the vendor of the library
    - \c VendorVersion: the version of the library
    - \c Extensions: a list of extensions supported (strings)
    - \c ApiFeature: a hash with a single key; the API feature name, where the value is the feature version
*/
static LdapClient::getInfo() [flags=CONSTANT] {
   return QoreLdapClient::getInfo();
}
