/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  QC_LdapClient.qpp
  
  Qore Programming Language
  
  Copyright 2003 - 2012 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.
  
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "openldap-module.h"

#include "QoreLdapClient.h"

class LdapClientHolder {
protected:
   QoreLdapClient* ldap;
   ExceptionSink* xsink;

public:
   DLLLOCAL LdapClientHolder(QoreLdapClient* l, ExceptionSink* xs) : ldap(l), xsink(xs) {
   }

   DLLLOCAL ~LdapClientHolder() {
      if (ldap) {
         ldap->destructor(xsink);
         ldap->deref(xsink);
      }
   }

   DLLLOCAL QoreLdapClient* release() {
      QoreLdapClient* l = ldap;
      ldap = 0;
      return l;
   }
};

/** @defgroup ldap_scope_constants LDAP Search Scope Constants
 */
//@{
namespace OpenLdap;

//! limits the search scope to the object itself
const LDAP_SCOPE_BASE = LDAP_SCOPE_BASE;

//! limits the search scope to the object's immediate children
const LDAP_SCOPE_ONELEVEL = LDAP_SCOPE_ONELEVEL;

//! limits the search scope to the object and all its descendants
const LDAP_SCOPE_SUBTREE = LDAP_SCOPE_SUBTREE;

//! limits the search scope to all of the descendants
/** this option is only supported on LDAP servers that support the LDAP Subordinates Search Scope extension
 */
const LDAP_SCOPE_CHILDREN = LDAP_SCOPE_CHILDREN;
//@}

/** @defgroup ldap_constants LDAP Constants
 */
//@{
namespace OpenLdap;

//! the default timeout value
const DefaultTimeout = 60s;
//@}

//! The LdapClient class 
/** 
 */
qclass LdapClient [arg=QoreLdapClient* ldap; dom=NETWORK];

//! Creates a new LdapClient object
/** 
    @par Example:
    @code
my LdapClient $ldap("ldaps://ldap.example.com:389");
    @endcode

    @param uri the URI of the ldap server (ex: \c "ldaps://ldap.example.com")
    @param options an optional hash of optional parameters, allowed keys are:
    - \c binddn: the dinstinguished name to use to bind to the LDAP server
    - \c password: the password to use for the connection
    - \c timeout: the default timeout for ldap operations; note that like all %Qore functions and methods taking timeout values, a relative date/time value can be used to make the units clear (i.e. \c 20s = twenty seconds, etc.); integers are treated as values in milliseconds, relative date/time values have a maximum resolution of 1 millisecond

    @throw LDAP-ERROR an error occurred creating the ldap session context
 */
LdapClient::constructor(string uri, *hash options) {
   LdapClientHolder ldap(new QoreLdapClient(uri, options, xsink), xsink);
   if (!*xsink)
      self->setPrivate(CID_LDAPCLIENT, ldap.release());
}

//! unbinds from the LDAP server (if a connection has been established) and destroys the object
/** @par Example:
    @code
delete $ldap;
    @endcode
 */
LdapClient::destructor() {
   ldap->destructor(xsink);
   ldap->deref(xsink);
}

//! Creates a new LdapClient object based on the original
/** 
    @par Example:
    @code
my LdapClient $ldap2 = $ldap.copy();
    @endcode

    @throw LDAP-ERROR an error occurred copying the ldap session context
 */
LdapClient::copy() {
   LdapClientHolder ldp(new QoreLdapClient(*ldap, xsink), xsink);
   if (!*xsink)
      self->setPrivate(CID_LDAPCLIENT, ldp.release());
}

//! bind to the server with the given authentication parameters
/** The current session is disconnected before binding again.

    @par Example:
    @code
$ldap.bind($h);
    @endcode

    @param bind a hash of bind parameters, allowed keys are:
    - \c binddn: the dinstinguished name to use to bind to the LDAP server
    - \c password: the password to use for the connection

    @throw LDAP-ERROR an error occurred performing the bind
 */
LdapClient::bind(hash bind) {
   ldap->bind(*bind, xsink);
}

//! performs a search on the LDAP server 
/** @par Example:
    @code
    @endcode
my hash $h = $ldap.search(("base": "dc=example,dc=cp,", "filter": "(objectClass=*)", "attributes": "uid");
    @param h a hash of search options with one or more of the following keys:
    - \c "base": the search base distinguished name for the search (ex: \c "dc=example,dc=com")
    - \c "filter": the search filter (ex: \c "(objectClass=*)")
    - \c "attributes": one or more attribute names; if this is present then only the given attributes will be returned
    - \c "scope": an integer giving the search scope; see @ref ldap_scope_constants for allowed values; note that if this key value is not present then @ref LDAP_SCOPE_SUBTREE is used

    @return a hash of the return value of the search; the hash is empty if no search results are available; the hash is keyed by Distinguished Names; each value is also a hash of attributes and attribute values
 */
hash LdapClient::search(hash h) {
   const QoreStringNode* base = check_hash_key<QoreStringNode>(*h, "base", "LDAP-SEARCH-ERROR", xsink);
   const QoreStringNode* filter = check_hash_key<QoreStringNode>(*h, "filter", "LDAP-SEARCH-ERROR", xsink);
   const AbstractQoreNode* n = h->getKeyValue("attributes");
   ReferenceHolder<QoreListNode> attrl(xsink);
   if (n) {
      if (n->getType() == NT_STRING) {
         attrl = new QoreListNode;
         attrl->push(n->refSelf());
      }
      else if (n->getType() == NT_LIST)
         attrl = reinterpret_cast<const QoreListNode*>(n)->listRefSelf();
      else {
         xsink->raiseException("LDAPCLIENT-SEARCH-ERROR", "the 'attributes' key of the search hash contains type '%s' (expecting 'list' or 'string')", get_type_name(n));
         return 0;
      }
   }

   // get scope
   n = h->getKeyValue("scope");
   int scope = n ? n->getAsInt() : 0;
   if (!scope)
      scope = LDAP_SCOPE_SUBTREE;
   
   return ldap->search(xsink, base, scope, filter, *attrl);
}

//! returns the URI string used to connect to the LDAP server
/** @par Example:
    @code
my string $uri = $ldap.getUri();
    @endcode

    @return the URI string used to connect to the LDAP server
*/
string LdapClient::getUri() [flags=CONSTANT] {
   return ldap->getUriStr();
}

//! Returns a hash with information about the openldap library
/** @return a hash with information about the openldap library with the following keys:
    - \c ApiVersion: the API version number
    - \c Protocol: the protocol number
    - \c VendorName: the vendor of the library
    - \c VendorVersion: the version of the library
    - \c Extensions: a list of extensions supported (strings)
    - \c ApiFeature: a hash with a single key; the API feature name, where the value is the feature version
*/
static LdapClient::getInfo() [flags=CONSTANT] {
   return QoreLdapClient::getInfo();
}
